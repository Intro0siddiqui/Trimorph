#!/bin/bash
set -euo pipefail

# Database management script for Trimorph

DB_FILE="/var/lib/trimorph/packages.db"
DB_DIR=$(dirname "$DB_FILE")

# Create database directory if it doesn't exist
sudo mkdir -p "$DB_DIR"
sudo chown "$(id -u):$(id -g)" "$DB_DIR" 2>/dev/null || true

# Initialize database if it doesn't exist
if [[ ! -f "$DB_FILE" ]]; then
    echo "{}" | sudo tee "$DB_FILE" > /dev/null
    sudo chown "$(id -u):$(id -g)" "$DB_FILE"
fi

# Function to read database
read_db() {
    if [[ -f "$DB_FILE" ]]; then
        cat "$DB_FILE"
    else
        echo "{}"
    fi
}

# Function to write to database
write_db() {
    local data="$1"
    echo "$data" | sudo tee "$DB_FILE" > /dev/null
    sudo chown "$(id -u):$(id -g)" "$DB_FILE"
}

# Function to add a package to the database
add_package() {
    local package="$1"
    local version="$2"
    local jail="$3"
    local install_log="$4"
    local files_json="$5"
    
    # Read current database
    local current_db
    current_db=$(read_db)
    
    # Create package entry
    local package_entry
    package_entry=$(cat <<EOF
{
  "version": "$version",
  "jail": "$jail",
  "install_log": "$install_log",
  "files": $files_json,
  "installed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF
)
    
    # Add to database using jq if available, otherwise use basic approach
    if command -v jq &> /dev/null; then
        # Use jq to update the database
        echo "$current_db" | jq --arg package "$package" --argjson entry "$package_entry" '.packages[$package] = $entry' | write_db
    else
        # Basic approach without jq - just overwrite the entry
        local new_db
        new_db=$(echo "$current_db" | python3 -c "
import sys, json
data = json.load(sys.stdin)
if 'packages' not in data:
    data['packages'] = {}
data['packages']['$package'] = json.loads('$package_entry'.replace('\\n', '\\\\n').replace('\\t', '\\\\t').replace('\\r', '\\\\r'))
json.dump(data, sys.stdout, indent=2)
")
        write_db "$new_db"
    fi
    
    echo "Package $package added to database"
}

# Function to remove a package from the database
remove_package() {
    local package="$1"
    
    if command -v jq &> /dev/null; then
        local current_db
        current_db=$(read_db)
        echo "$current_db" | jq --arg package "$package" 'del(.packages[$package])' | write_db
    else
        # Simple approach without jq
        local current_db
        current_db=$(read_db)
        local new_db
        new_db=$(echo "$current_db" | python3 -c "
import sys, json
data = json.load(sys.stdin)
if 'packages' in data and '$package' in data['packages']:
    del data['packages']['$package']
json.dump(data, sys.stdout, indent=2)
")
        write_db "$new_db"
    fi
    
    echo "Package $package removed from database"
}

# Function to list all packages
list_packages() {
    local db_content
    db_content=$(read_db)
    
    if command -v jq &> /dev/null; then
        echo "$db_content" | jq -r '.packages | to_entries[] | "\(.key) (\(.value.version)) from jail \(.value.jail)"'
    else
        # Simple approach without jq
        python3 -c "
import json
import sys
db = json.loads('''$db_content''')
if 'packages' in db:
    for pkg, info in db['packages'].items():
        version = info.get('version', 'unknown')
        jail = info.get('jail', 'unknown')
        print(f'{pkg} ({version}) from jail {jail}')
"
    fi
}

# Parse command
case "${1:-}" in
    add-package)
        if [[ $# -lt 6 ]]; then
            echo "Usage: $0 add-package <package> <version> <jail> <install_log> <files_json>"
            exit 1
        fi
        add_package "$2" "$3" "$4" "$5" "$6"
        ;;
    remove-package)
        if [[ $# -lt 2 ]]; then
            echo "Usage: $0 remove-package <package>"
            exit 1
        fi
        remove_package "$2"
        ;;
    list-packages)
        list_packages
        ;;
    *)
        echo "Usage: $0 {add-package|remove-package|list-packages}"
        echo "  add-package <package> <version> <jail> <install_log> <files_json>"
        echo "  remove-package <package>"
        echo "  list-packages"
        exit 1
        ;;
esac