#!/bin/bash
# Robust, safe INI parser â€” NO eval, NO code injection

set -euo pipefail

# Require a config file argument before accessing $1
if [[ $# -lt 1 ]]; then
    echo "usage: $0 <config-file>" >&2; exit 1
fi
conf="$1"
if [[ ! -f "$conf" ]]; then
    echo "error: config not found: $conf" >&2; exit 1
fi

# Read the file line by line, handling keys and values robustly.
while IFS= read -r line || [[ -n "$line" ]]; do
    # Skip comments and empty lines
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    [[ -z "${line// }" ]] && continue

    # Ensure the line contains an equals sign
    if [[ "$line" != *"="* ]]; then
        continue
    fi

    # Extract key and value using parameter expansion for robustness
    key="${line%%=*}"
    value="${line#*=}"

    # Clean up whitespace from key and value using pure bash
    key_clean="${key#"${key%%[![:space:]]*}"}"
    key_clean="${key_clean%"${key_clean##*[![:space:]]}"}"
    value_clean="${value#"${value%%[![:space:]]*}"}"
    value_clean="${value_clean%"${value_clean##*[![:space:]]}"}"

    # Validate key is a safe shell identifier (prevents code injection via key)
    if [[ ! "$key_clean" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
        echo "warn: skipping invalid key '$key_clean'" >&2
        continue
    fi

    # Output as shell assignments (safe for source via %q)
    printf 'TRIMORPH_%s=%q\n' "$key_clean" "$value_clean"
done < "$conf"