#!/bin/bash
set -euo pipefail

# Check for required dependencies
check_dependencies() {
    local missing_deps=()

    # Check for required commands (for OpenRC systems, we might have bubblewrap instead of systemd-nspawn)
    for cmd in sudo mktemp find file dpkg rpm tar zstd bsdtar python3; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_deps+=("$cmd")
        fi
    done

    # Check for at least one of systemd-nspawn or bwrap (for OpenRC)
    if ! command -v systemd-nspawn &> /dev/null && ! command -v bwrap &> /dev/null; then
        missing_deps+=("systemd-nspawn or bwrap")
    fi

    # Check for jq (optional but preferred)
    if ! command -v jq &> /dev/null; then
        echo "Warning: jq not found, falling back to python for JSON operations"
    fi

    # Check for required trimorph scripts
    local script_dir=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &> /dev/null && pwd)
    for script in trimorph-parse-conf trimorph-db trimorph-auto-update; do
        if [[ ! -x "$script_dir/../bin/$script" ]]; then
            # Check alternative location
            if [[ ! -x "/usr/local/bin/$script" ]]; then
                missing_deps+=("/usr/local/bin/$script")
            fi
        fi
    done

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        echo "Error: Missing required dependencies:"
        for dep in "${missing_deps[@]}"; do
            echo "  - $dep"
        done
        exit 1
    fi
}

check_dependencies

# --- Self-locating Script ---
SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &> /dev/null && pwd)

# Allow overriding paths for testing, with sensible defaults
TRIMORPH_ETC_DIR="${TRIMORPH_ETC_DIR:-/etc/trimorph}"
TRIMORPH_BASE_DIR="${TRIMORPH_BASE_DIR:-/usr/local/trimorph/base}"
TRIMORPH_CACHE_DIR="${TRIMORPH_CACHE_DIR:-/var/cache/trimorph/packages}"
TRIMORPH_EXPORT_DIR="${TRIMORPH_EXPORT_DIR:-/var/cache/trimorph/export}"

# Check required arguments
if [[ $# -lt 1 ]]; then
    echo "Usage: $0 <package_file> [package_file...]"
    echo "Supports: .deb, .rpm, .pkg.tar.zst, .apk, .tbz, .pkg.tar.xz, .pkg.tar.gz"
    exit 1
fi

# Validate package files exist
for pkg_file in "$@"; do
    if [[ ! -f "$pkg_file" ]]; then
        echo "Error: Package file not found: $pkg_file"
        exit 1
    fi
done

# Function to detect package format based on extension and file command
detect_package_format() {
    local file_path="$1"
    local extension="${file_path##*.}"
    local two_ext="${file_path%.*}"
    two_ext="${two_ext##*.}.${extension}"
    local three_ext="${file_path%.*.*}"
    three_ext="${three_ext##*.}.${two_ext}"
    
    case "${three_ext}" in
        pkg.tar.zst) echo "pacman"; return 0 ;;
        pkg.tar.xz) echo "pacman"; return 0 ;;
        pkg.tar.gz) echo "pacman"; return 0 ;;
    esac
    
    case "${two_ext}" in
        *.tar.zst) echo "pacman"; return 0 ;;
        *.tar.xz) echo "pacman"; return 0 ;;
        *.tar.gz) echo "pacman"; return 0 ;;
    esac
    
    case "${extension}" in
        deb) echo "dpkg"; return 0 ;;
        rpm) echo "rpm"; return 0 ;;
        apk) echo "apk"; return 0 ;;
        tbz) echo "zypper"; return 0 ;;
        pkg) echo "pacman"; return 0 ;;
        *)
            # Use file command to detect format
            local file_type
            file_type=$(file -b "$file_path" 2>/dev/null || true)
            case "$file_type" in
                *Debian*|*"POSIX tar") echo "dpkg"; return 0 ;;
                *RPM*) echo "rpm"; return 0 ;;
                *zstd*) echo "pacman"; return 0 ;;
                *"XZ compressed"*) echo "pacman"; return 0 ;;
                *"gzip compressed"*) echo "pacman"; return 0 ;;
                *) echo "unknown"; return 1 ;;
            esac
            ;;
    esac
}

# Function to normalize dependency string by removing version constraints
normalize_dependencies() {
    local deps="$1"
    # Remove version constraints like (>= 1.0), (<< 2.0), etc.
    echo "$deps" | sed 's/([^)]*)//g' | sed 's/|/ /g' | tr ',' ' ' | tr '|' ' ' | xargs -n1 | sort -u | xargs
}

# Function to extract package information (name, version, dependencies)
extract_package_info() {
    local pkg_file="$1"
    local pkg_format="$2"
    
    case "$pkg_format" in
        dpkg)
            # Extract package name and dependencies from .deb file
            local pkg_name
            local pkg_version
            local dependencies
            
            pkg_name=$(dpkg-deb --field "$pkg_file" Package 2>/dev/null || echo "unknown")
            pkg_version=$(dpkg-deb --field "$pkg_file" Version 2>/dev/null || echo "unknown")
            dependencies=$(dpkg-deb --field "$pkg_file" Depends 2>/dev/null || echo "")
            # Normalize dependencies
            dependencies=$(normalize_dependencies "$dependencies")
            ;;
        rpm)
            # Extract package name and dependencies from .rpm file
            local pkg_name
            local pkg_version
            local dependencies
            
            pkg_name=$(rpm -qp --qf '%{NAME}' "$pkg_file" 2>/dev/null || echo "unknown")
            pkg_version=$(rpm -qp --qf '%{VERSION}-%{RELEASE}' "$pkg_file" 2>/dev/null || echo "unknown")
            # Get requires dependencies
            dependencies=$(rpm -qp --requires "$pkg_file" 2>/dev/null | grep -v "rpmlib(" | grep -v "config(" | xargs | tr ' ' ',')
            # Normalize dependencies
            dependencies=$(normalize_dependencies "$dependencies")
            ;;
        pacman)
            # Extract package name and dependencies from pacman package
            local temp_dir
            temp_dir=$(mktemp -d)
            # Try to extract the .PKGINFO file
            if tar -I zstd -tf "$pkg_file" 2>/dev/null | grep -q ".PKGINFO"; then
                tar -I zstd -xf "$pkg_file" -C "$temp_dir" .PKGINFO 2>/dev/null
            elif command -v bsdtar &> /dev/null && bsdtar -tf "$pkg_file" 2>/dev/null | grep -q ".PKGINFO"; then
                bsdtar -xf "$pkg_file" -C "$temp_dir" .PKGINFO 2>/dev/null
            else
                # Try with xz or gz
                if tar -Jtf "$pkg_file" 2>/dev/null | grep -q ".PKGINFO"; then
                    tar -Jxf "$pkg_file" -C "$temp_dir" .PKGINFO 2>/dev/null
                elif tar -ztf "$pkg_file" 2>/dev/null | grep -q ".PKGINFO"; then
                    tar -zxf "$pkg_file" -C "$temp_dir" .PKGINFO 2>/dev/null
                fi
            fi
            
            if [[ -f "$temp_dir/.PKGINFO" ]]; then
                pkg_name=$(grep -E '^name' "$temp_dir/.PKGINFO" | cut -d= -f2 | xargs || echo "unknown")
                pkg_version=$(grep -E '^version' "$temp_dir/.PKGINFO" | cut -d= -f2 | xargs || echo "unknown")
                dependencies=$(grep -E '^depend' "$temp_dir/.PKGINFO" | cut -d= -f2- | xargs || echo "")
                # Normalize dependencies (each line is a separate dependency)
                local normalized_deps=""
                while IFS= read -r depend; do
                    if [[ -n "$depend" ]]; then
                        depend=$(normalize_dependencies "$depend")
                        if [[ -n "$depend" ]]; then
                            normalized_deps="$normalized_deps $depend"
                        fi
                    fi
                done < <(grep -E '^depend' "$temp_dir/.PKGINFO" | cut -d= -f2-)
                dependencies=$(echo "$normalized_deps" | xargs)
            else
                pkg_name="unknown"
                pkg_version="unknown"
                dependencies=""
            fi
            rm -rf "$temp_dir"
            ;;
        apk)
            # Extract package name and dependencies from .apk file
            local temp_dir
            temp_dir=$(mktemp -d)
            # APK files are tar.gz archives with control and data tars inside
            tar -xzf "$pkg_file" -C "$temp_dir" 2>/dev/null || true
            if [[ -f "$temp_dir/control" ]]; then
                pkg_name=$(grep -E '^pkgname:' "$temp_dir/control" | cut -d: -f2 | xargs || echo "unknown")
                pkg_version=$(grep -E '^pkgver:' "$temp_dir/control" | cut -d: -f2 | xargs || echo "unknown")
                dependencies=$(grep -E '^depends:' "$temp_dir/control" | cut -d: -f2- | xargs || echo "")
                # Normalize dependencies
                dependencies=$(normalize_dependencies "$dependencies")
            else
                pkg_name="unknown"
                pkg_version="unknown"
                dependencies=""
            fi
            rm -rf "$temp_dir"
            ;;
        *)
            echo "Unknown package format: $pkg_format"
            return 1
            ;;
    esac
    
    echo "$pkg_name|$pkg_version|$dependencies"
}

# Function to check if a package is already installed on the host system
is_package_installed() {
    local pkg_name="$1"
    local pkg_format="$2"
    
    case "$pkg_format" in
        dpkg)
            if command -v dpkg &> /dev/null; then
                dpkg -l "$pkg_name" 2>/dev/null | grep -q "^ii"
                return $?
            fi
            ;;
        rpm)
            if command -v rpm &> /dev/null; then
                rpm -q "$pkg_name" &>/dev/null
                return $?
            fi
            ;;
        pacman)
            if command -v pacman &> /dev/null; then
                pacman -Q "$pkg_name" &>/dev/null
                return $?
            fi
            ;;
        apk)
            if command -v apk &> /dev/null; then
                apk info "$pkg_name" &>/dev/null
                return $?
            fi
            ;;
    esac
    return 1
}

# Function to install dependencies using appropriate jail
install_dependencies() {
    local dependencies="$1"
    local pkg_format="$2"
    
    if [[ -z "$dependencies" ]]; then
        echo "No dependencies to install."
        return 0
    fi
    
    echo "Installing dependencies: $dependencies"
    
    # Map package format to appropriate jail
    local jail_name
    case "$pkg_format" in
        dpkg) jail_name="deb" ;;
        rpm) jail_name="fedora" ;;
        pacman) jail_name="arch" ;;
        apk) jail_name="alpine" ;;
        *) 
            echo "Warning: Unsupported package format for dependency installation: $pkg_format"
            return 1
            ;;
    esac
    
    # Check if jail exists and is bootstrapped
    if [[ ! -f "/etc/trimorph/jails.d/$jail_name.conf" ]]; then
        echo "Warning: Configuration file not found for jail: $jail_name"
        return 1
    fi
    
    if [[ ! -d "/usr/local/trimorph/base/$jail_name" ]]; then
        echo "Warning: Base image not found for jail: $jail_name. Run 'sudo trimorph-bootstrap $jail_name'"
        return 1
    fi
    
    # Install dependencies using trimorph
    for dep in $dependencies; do
        if [[ -n "$dep" ]]; then
            # Skip if already installed
            if is_package_installed "$dep" "$pkg_format"; then
                echo "Dependency $dep already installed on host, skipping..."
                continue
            fi
            
            echo "Installing dependency: $dep using jail: $jail_name"
            if command -v trimorph-install-to-host &> /dev/null; then
                trimorph-install-to-host "$jail_name" "$dep" || echo "Failed to install dependency: $dep"
            else
                echo "trimorph-install-to-host command not found. Cannot install dependency: $dep"
            fi
        fi
    done
}

# Function to extract files from package to a directory
extract_package_files() {
    local pkg_file="$1"
    local pkg_format="$2"
    local extract_dir="$3"
    
    case "$pkg_format" in
        dpkg)
            dpkg-deb -x "$pkg_file" "$extract_dir"
            ;;
        rpm)
            mkdir -p "$extract_dir"
            rpm2cpio "$pkg_file" | cpio -id -D "$extract_dir" 2>/dev/null
            ;;
        pacman)
            if command -v bsdtar &> /dev/null; then
                bsdtar -xf "$pkg_file" -C "$extract_dir" 2>/dev/null
            else
                # Try to use tar with appropriate compression
                if tar -I zstd -tf "$pkg_file" &> /dev/null; then
                    tar -I zstd -xf "$pkg_file" -C "$extract_dir" 2>/dev/null
                elif tar -Jtf "$pkg_file" &> /dev/null; then
                    tar -Jxf "$pkg_file" -C "$extract_dir" 2>/dev/null
                elif tar -ztf "$pkg_file" &> /dev/null; then
                    tar -zxf "$pkg_file" -C "$extract_dir" 2>/dev/null
                else
                    echo "Error: Unable to extract pacman package: $pkg_file"
                    return 1
                fi
            fi
            ;;
        apk)
            # APK files have data.tar.gz inside
            local temp_dir
            temp_dir=$(mktemp -d)
            tar -xzf "$pkg_file" -C "$temp_dir" 2>/dev/null
            # Extract the data.tar.gz if it exists
            if [[ -f "$temp_dir/data.tar.gz" ]]; then
                tar -xzf "$temp_dir/data.tar.gz" -C "$extract_dir"
            elif [[ -f "$temp_dir/data.tar.xz" ]]; then
                tar -xJf "$temp_dir/data.tar.xz" -C "$extract_dir"
            elif [[ -f "$temp_dir/data.tar.zst" ]]; then
                tar -I zstd -xf "$temp_dir/data.tar.zst" -C "$extract_dir"
            else
                # If no data archive found, try to find and extract the right one
                local data_file
                for data_file in "$temp_dir"/*.tar.*; do
                    if [[ -f "$data_file" ]]; then
                        case "$data_file" in
                            *.gz) tar -xzf "$data_file" -C "$extract_dir" ;;
                            *.xz) tar -xJf "$data_file" -C "$extract_dir" ;;
                            *.zst) tar -I zstd -xf "$data_file" -C "$extract_dir" ;;
                            *) echo "Unsupported archive format: $data_file" ;;
                        esac
                        break
                    fi
                done
            fi
            rm -rf "$temp_dir"
            ;;
        *)
            echo "Unsupported package format for extraction: $pkg_format"
            return 1
            ;;
    esac
}

# Process each package file
for pkg_file in "$@"; do
    echo "Processing package: $pkg_file"
    
    # Detect package format
    pkg_format=$(detect_package_format "$pkg_file")
    if [[ "$pkg_format" == "unknown" ]]; then
        echo "Error: Unknown package format for: $pkg_file"
        exit 1
    fi
    
    echo "Detected package format: $pkg_format"
    
    # Extract package information
    pkg_info=$(extract_package_info "$pkg_file" "$pkg_format")
    IFS='|' read -r pkg_name pkg_version pkg_dependencies <<< "$pkg_info"
    
    echo "Package name: $pkg_name"
    echo "Package version: $pkg_version"
    echo "Package dependencies: $pkg_dependencies"
    
    # Install dependencies if any
    if [[ -n "$pkg_dependencies" ]]; then
        echo "Installing dependencies for $pkg_name..."
        install_dependencies "$pkg_dependencies" "$pkg_format"
    fi
    
    # Create temporary directory for extraction
    work_dir=$(mktemp -d "/tmp/trimorph_local_install_XXXXXX")
    trap 'rm -rf "$work_dir"' EXIT
    
    # Extract package files to work directory
    echo "Extracting package contents..."
    if ! extract_package_files "$pkg_file" "$pkg_format" "$work_dir"; then
        echo "Error: Failed to extract package: $pkg_file"
        rm -rf "$work_dir"
        exit 1
    fi
    
    # Analyze extracted files and create manifest
    echo "Analyzing package contents..."
    find "$work_dir" -type f -exec echo {} \; | sed "s|$work_dir||" | grep -v '^$' | sort > "$work_dir/manifest.txt"
    
    # Show what would be installed
    echo "Files to be installed:"
    cat "$work_dir/manifest.txt"
    
    # Ask for confirmation before installing to host
    echo
    read -p "Do you want to install these files to the host system? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Installation cancelled for: $pkg_file"
        continue
    fi
    
    # Create installation manifest file
    install_timestamp=$(date +%s)
    install_log="/var/lib/trimorph/host-installs/local_${pkg_name}_${install_timestamp}.log"
    sudo mkdir -p /var/lib/trimorph/host-installs
    sudo chown "$(id -u):$(id -g)" /var/lib/trimorph/host-installs 2>/dev/null || true
    
    # Write initial log information
    {
        echo "# Local package installation log for: $pkg_file"
        echo "# Package name: $pkg_name"
        echo "# Package version: $pkg_version"
        echo "# Package format: $pkg_format"
        echo "# Original file: $pkg_file"
        echo "# Timestamp: $install_timestamp"
        echo "# Date: $(date)"
        echo "# SHA256 checksum: $(sha256sum "$pkg_file" | cut -d' ' -f1)"
        echo "# Files installed:"
    } | sudo tee "$install_log" > /dev/null
    
    # Install files to host with conflict checking
    echo "Installing files to host system..."
    installed_files=()
    conflicts=()
    
    while IFS= read -r file_path; do
        if [[ -n "$file_path" ]]; then
            full_source_path="$work_dir$file_path"
            full_dest_path="$file_path"
            
            # Check if destination already exists
            if [[ -e "$full_dest_path" ]]; then
                conflicts+=("$full_dest_path")
                echo "CONFLICT: $full_dest_path already exists. Skipping..."
                continue
            fi
            
            # Create parent directory if it doesn't exist
            dest_dir=$(dirname "$full_dest_path")
            sudo mkdir -p "$dest_dir"
            
            # Copy the file preserving permissions
            sudo cp -a "$full_source_path" "$full_dest_path"
            echo "Installed: $full_dest_path"
            installed_files+=("$full_dest_path")
            
            # Log the installed file
            echo "$full_dest_path" | sudo tee -a "$install_log" >> /dev/null
        fi
    done < "$work_dir/manifest.txt"
    
    # Report conflicts if any
    if [[ ${#conflicts[@]} -gt 0 ]]; then
        echo
        echo "WARNING: The following files were not installed due to conflicts:"
        for conflict in "${conflicts[@]}"; do
            echo "  - $conflict"
        done
        echo "You may need to manually handle these conflicts."
    fi
    
    # Add to database with files list as JSON array
    files_json="["
    first=true
    for file in "${installed_files[@]}"; do
        if [ "$first" = true ]; then
            files_json="$files_json\\\"$file\\\""
            first=false
        else
            files_json="$files_json, \\\"$file\\\""
        fi
    done
    files_json="$files_json]"
    
    # Add to database as a local package
    /usr/local/bin/trimorph-db add-package "$pkg_name" "$pkg_version" "local" "$install_log" "$files_json" || true
    
    # Update desktop database if desktop files were installed
    if find "$work_dir" -name "*.desktop" -type f | grep -q .; then
        echo "Updating desktop database..."
        if command -v update-desktop-database &> /dev/null; then
            update-desktop-database ~/.local/share/applications 2>/dev/null || true
            update-desktop-database /usr/share/applications 2>/dev/null || true
        fi
    fi
    
    # Clean up work directory
    rm -rf "$work_dir"
    
    echo
    echo "Installation of $pkg_name completed!"
    echo "Files installed from local package: $pkg_file"
    echo "Installation log: $install_log"
    echo "To uninstall, run: trimorph-uninstall-local $install_log"
done

echo
echo "All packages processed."